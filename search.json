[{"title":"Preprocess the Image Data by NPP in TensorRT Model Inference","date":"2020-06-17T05:00:00.000Z","url":"/2020/06/17/en/trt_preproc_npp/","tags":[["cpp","/tags/cpp/"],["cuda","/tags/cuda/"],["tensorrt","/tags/tensorrt/"]],"categories":[[" ",""]],"content":"NVIDIA TensorRT(TRT) library is a high-performance deep learning inference engine and delivers low latency and high-throughput for deep learning inference applications. It allows users to convert the model from other popular frameworks like pytorch or tensorflow. However, TensorRT only supports float32 rather than uint8 data type as input data type, which is the most common format for image data. In this case, when we try to deploy the image-based tasks with TensorRT, it always needs to convert the images from uint8 to float32, and then transfer the float32 image date to gpu to allow the TRT engine inference the model. When the image size is large, this preprocessing stage is slightly slow. In this blog, we are trying to introduce the NVIDIA NPP library to speed up this preprocessing progress. ExperimentsThis blog uses the environment shown below and used a detection model trained by ssds.pytorch to do the experiments and evaluations. The model uses ResNet18 as feature extractor and YoloV3 as detection head. The model has already been converted to TRT with 1x3x736x1280 input and int8 computation precision. It should be noted that when the model is converted to a TRT model, TRT will select different kernel functions and their parameters according to the GPU framework, and thus optimize the inference speed. Therefore, it has to use the same GPU framework for TRT model generation and execution. And even the TRT model generated by different types of GPUs with the same framework, its inference speed will be slightly weakened based on its execution gpu machine. For example, although 2080ti and t4 belong to the same 7.5 computing framework, when we infer the model on T4, the model generated by 2080ti is 3 to 10% slower than the model generated by T4. CPU image preprocessingIn some deep learning frameworks, it can specify the input data type &amp; format and the data preprocessing ops in the inference graph. For example, when we freeze the weights into the frozen graph in tensorflow, we can specify the data type accepted by the model during inference through tf.placeholder(dtype=tf.uint8, shape=input_shape, name=&#39;image_tensor&#39;). This preprocessing way is not supportted on TensorRT. TensorRT does support multiple data types, and the data type of the input and output ops can be determined by the converted onnx&#x2F;uff file. However, when the input and output data type of onnx&#x2F;uff model is changed to other types than float32, it can not be successfully converted into a TRT inference model in the most cases. This data type limitation in TensorRT is even more unfriendly to the computer vision models. Images or videos in computer vision tasks are often stored in the computer as uint8 data ([0, 255]) which is not supported by TensorRT. In this case, the images must be converted to float and then do the TensorRT model inference. In some tasks, the resolution of the images or video clips of the input model is large, such as 4k or 8k, and it is slow to tranfer the data from uint8 to float in cpu and from cpu memory to gpu memory. In some cases, the time cost of pre-processing and transmission is the bottleneck in model deployment. Most of the TRT projects on github often use the official TensorRT example to preprocess the image data in cpu, while I prefer to use the OpenCV functions to preprocess the images. The code for these two methods are shown as below. Code: Preprocess data in cpu TensorRT official preprocessing code OpenCV preprocessing code The time cost of OpenCV preprocessing method(ms) GPU(Precision) Image2Float Copy2GPU Inference GPU2CPU t4(int8) 2.53026 0.935451 2.56143 0.0210528 As shown in the example preprocessing code above, in the cpu, the data is first converted to float type and normalized to [0,1]. The arrangement is also permuted from NHWC to NCHW. Then the float data is transferred to gpu memory to do TRT model inference. In the time cost table, it shows that the speed of image preprocessing and transmission for this model is actually greater than the speed of model inference. In this case, the model deployed in gpu is not efficient and still has room to speed up. GPU Image Preprocessing by NPPAs mentioned, there are two reasons make the CPU image data preprocessing slow: the efficiency of CPU to convert the image from uint8 to float32 is low; since the float32 data is 4 times larger than uint8 data, the transmission efficiency between cpu memory and gpu memory is slower for float data. In this case, a simple speed-up way is to transfer uint8 data to gpu and allows gpu to complete the conversion from uint8 to float32. These processes can be done by NPP easily and efficiently. Nvidia NPP is a cuda library for GPU accelerated 2D image and signal processing. It contains multiple submodules, which allows users to efficiently do the image computation on the gpu like the data type conversion, the color or geometric transformation and etc.. In this example, the NPPC, NPPIDEI and NPPIAL in NPP are used to perform the data type conversion from uint8 to float32 in the image data preprocessing, the channel change from NHWC to NCHW, and the normalization. The code is shown as follows. Code: Preprocess data in gpu NPP preprocessing code NPP preprocessing code (without normalization and channel permutation) The time cost of NPP preprocessing (without normalization and channel permutation) (ms) GPU(Precision) Image2GPU2Float Inference GPU2CPU t4(int8) 0.532469 3.07869 0.0208867 As shown in the example code above, for preprocessing in the gpu, the uint8 data is first transferred to the gpu memory. Then the data arrangement is permuted from NHWC to NCHW and finally the uint8 data converted to the float type and normalized to [0., 1.]. The normalized data is directly stored in the gpu memory reserved by the TRT model. Since elementwise operation and channel permute are performed efficiently in the TRT model, the normalization and channel conversion in the preprocessing can be moved to the model as operations. Compared with CPU image preprocessing, the GPU image preprocessing time is reduced from 3.5ms to 0.5ms, the total running time of the entire model is reduced from 6ms to 3.5ms, and the frame processing per second (fps) is from 166 frames raised to 285 frames, the overall speed has reached 1.7 times faster. It should be noted that due to the long conversion time of the TRT model, the example in this blog only tests the execution speed when batch is 1. If large batches are encountered during deployment and the gpu preprocessing speed is slow, it may be due to the cuda code execution and transmission. In this case, it would be better to copy the entire batch of images to the GPU memory and the data type conversion to improve the preprocessing speed in the batch. Another way to speed up the progress is process each image sample in a stream. Reference tensorrt document gpu computation framework ssds.pytorch "},{"date":"2022-02-27T01:01:34.883Z","url":"/categories/index.html","categories":[[" ",""]]},{"date":"2022-02-27T01:02:31.027Z","url":"/search/index.html","categories":[[" ",""]]},{"date":"2022-02-27T01:01:38.657Z","url":"/tags/index.html","categories":[[" ",""]]}]